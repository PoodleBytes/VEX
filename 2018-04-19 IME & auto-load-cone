#pragma config(UART_Usage, UART2, uartNotUsed, baudRate4800, IOPins, None, None)
#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    armPot,         sensorPotentiometer)
#pragma config(Sensor, in2,    goalerPot,      sensorPotentiometer)
#pragma config(Sensor, dgtl3,  heightEncoder,  sensorQuadEncoder)
#pragma config(Sensor, I2C_1,  rightEncoder,   sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  leftEncoder,    sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           goalerMotor,   tmotorVex393_HBridge, openLoop, reversed)
#pragma config(Motor,  port2,           rightFront,    tmotorVex393HighSpeed_MC29, openLoop, reversed, encoderPort, I2C_1)
#pragma config(Motor,  port3,           leftFront,     tmotorVex393HighSpeed_MC29, openLoop, encoderPort, I2C_2)
#pragma config(Motor,  port4,           heightRight,   tmotorVex393TurboSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           armRight,      tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           rightRear,     tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           leftRear,      tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port8,           armLeft,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           heightLeft,    tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port10,          clawMotor,     tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX2) // This code is for the VEX cortex platform
#pragma competitionControl(Competition) // Select Download method as "competition"
#include "Vex_Competition_Includes.c" //Main competition background code...do not modify!
#pragma systemFile

//============= Competition template for VEX EDR =============
// Pre-Autonomous Functions  All activities that occur before the competition starts ie clearing encoders, setting servo positions, ..
void pre_auton()
{
	bStopTasksBetweenModes = true;
	bDisplayCompetitionStatusOnLcd = false;
	slaveMotor(armRight,armLeft);
	slaveMotor(heightRight,heightLeft);

	//intialize IME
	//Completely clear out any previous sensor readings by setting the port to "sensorNone"
	SensorType[I2C_1] = sensorNone;
	SensorType[I2C_2] = sensorNone;
	wait1Msec(1000);
	//Reconfigure Analog Port 8 as a Gyro sensor and allow time for ROBOTC to calibrate it
	SensorType[I2C_1] = sensorQuadEncoderOnI2CPort;
	SensorType[I2C_2] = sensorQuadEncoderOnI2CPort;
	wait1Msec(2000);
}//end pre_run


/*  when loading cone on Mobile Goal (MG) the claw can open wide than arm and get wreak havoc (bust chain, jam)
this version tries to stop the arm at coneZone - well before reaching armPot(max)
1 - slowly lift arm (in arm task)
2 - pause a moment to makesure claw is clear (arm & claw task)
3 - slowly open claw - (claw task)
4 - once clear - resume normal control
** TO DO soft limie limit how far the arm can go over goaler. Try for horizontal (drop cone OK & keeps claws constrained by brackets)
*/

//IT IS IMPERITIVE CO CONFIRM THE VARIABLES vs SENSOR VALUES frequently!!!
int armMax = 4000;	//armPot's value at max angle
int coneZone = armMax; //'sweet-spot' armPot reading where claw is intent on dropping cone. threshold where claw in danger
int greyZone = 800; //+- range grey-area where arm's between arm being forward & backward
int armLift = -50;	//direction / power applied to arm to slowly
int clawOpen = -40; //claw open direction / power
int pause1 = 30;	//first delay (in milli sec) before claw opens
int pause2 = 400;	//first delay (in milli sec) before claw opens
int clawPower = 0;


// global varaibles
int deadband = 20;
int MAX_POWER = 100;
int leftPower = 0;
int rightPower = 0;
int armAngle = 0;
int goalerAngle = 0;

task autonomous()
{
	//COPY & PAST AUTONOMOUS HERE!!
}	//end autonomous

task claw(){	while(true){
		if(vexRT[Btn5DXmtr2] == 1 || vexRT[Btn5UXmtr2] == 1)       	//CLOSE CLAW
		{
			motor[clawMotor]=MAX_POWER;
			wait1Msec(500);
			clawPower=20; //hold claw shut
		}
		if(vexRT[Btn6DXmtr2] == 1 || vexRT[Btn6UXmtr2] == 1)  	//OPEN CLAW
		{
			clawPower = 0;
			if(SensorValue(armPot) <coneZone)
			{ //fully open claw
				motor[clawMotor]=MAX_POWER * -1 ;
				wait1Msec(500);
				motor[clawMotor]=clawPower;

			}
			else if(SensorValue(armPot) >coneZone-greyZone) //claw opens slowly - param from auto say 30 for 300ms
			{ //arm past verticle, partial open claw
				motor[clawMotor]=clawOpen;
				wait1Msec(200);
				motor[clawMotor]=clawPower;
			}
		}
		else
		{
			motor[clawMotor]=clawPower;      	//...stop the motor[.
		}
	}//end while
}//end claw

task arm(){		// ARM CONTROL
	while(true){
		if((vexRT[Ch2Xmtr2]) > deadband)	{ //move arm until coming close to cone zone
			if(SensorValue(armPot)< coneZone){
				motor[armLeft]=vexRT[Ch2Xmtr2]*0.8;
			}
			else if(SensorValue(armPot)> armMax-greyZone){
				motor[armLeft]=vexRT[Ch2Xmtr2]*0.5;  //  **** 	ANOTHER PLACE WHERE ARM SLOWS DOWN
			}
		}
		else if(vexRT[Ch2Xmtr2] < deadband * -1)	{ //move arm toward front
			motor[armLeft]=vexRT[Ch2Xmtr2]*0.8;
		}
		else { //no movement - try to "soft lock" motors
			if(SensorValue(armPot) >700 && SensorValue(armPot) <coneZone - greyZone){ //arm is high enough to need soft lock but not past verticle
				motor[armLeft]=15;
			}
			else if(SensorValue(armPot) >coneZone){
				motor[armLeft]=-20;
			}
			else{
				motor[armLeft]=0;
			}
		}
	}
}//end arm

task drive(){		//DRIVE CONTROL
	while(true){
		// calculate arcade drive motor[ power
		if(abs((vexRT[Ch2] + vexRT[Ch1]))>deadband){
			leftPower =(vexRT[Ch2] + vexRT[Ch1])* 0.8;
			rightPower =(vexRT[Ch2] - vexRT[Ch1]) * 0.8;
		}
		else {
			leftPower = 0;
			rightPower = 0;
		}
		// check against maximum
		if( abs(rightPower) > MAX_POWER)
			rightPower = sgn(rightPower) * MAX_POWER;
		if( abs(leftPower) > MAX_POWER )
			leftPower = sgn(leftPower) * MAX_POWER;
		motor[leftRear]= motor[leftFront]=leftPower;
		motor[rightRear]= motor[rightFront]=rightPower;
	}//end while
}//end drive

void clawOverGoal(void) { //claw/arm routing from autonomous
	stopTask(arm);
	stopTask(claw);
	while(SensorValue(armPot)<3500){
		motor[armLeft]=MAX_POWER;	}
	motor[clawMotor]=-20;
	motor[armLeft]=0;
	wait1Msec(200);
	wait1Msec(100);
	motor[clawMotor]=0;
	motor[armLeft]=MAX_POWER * -1;
	wait1Msec(1500);
	motor[armLeft]=0;
	motor[clawMotor]=clawOpen;
	wait1Msec(250);
	motor[clawMotor]=0;
	clawPower=0;
	startTask(arm);
	startTask(claw);
}


task usercontrol()
{
	//start control tasks
	startTask(drive);
	startTask(claw);
	startTask(arm);

	//zero encoders
	SensorValue(heightEncoder)=0;
	resetMotorEncoder(rightFront);
	resetMotorEncoder(leftFront);


	while(true){
		armAngle = SensorValue(armPot);
		goalerAngle = SensorValue(goalerPot);
		// GOALER
		if(abs(vexRT[Ch3]) > deadband)       	//If button 7L is pressed...
		{
			motor[goalerMotor]=vexRT[Ch3];    	//...raise the goalerSetMotor.
		}
		else                      		//Else (neither button is pressed)...
		{
			motor[goalerMotor]=0;      	//...stop the goalerSetMotor.
		}
		if(vexRT[Btn7D]==1){
			while(SensorValue(goalerPot)>1000){
				motor[goalerMotor] = -60;
			}
		}

		//automatically dump cone on goaler
		if(vexRT[Btn8RXmtr2]==1){clawOverGoal();};

		//HEIGHT
		if(abs(vexRT[Ch3Xmtr2])> deadband)
		{
			motor[heightLeft]=vexRT[Ch3Xmtr2];
		}
		else
		{
			motor[heightLeft]=0;
		}
	}//end while
}//end userControl
