#pragma config(UART_Usage, UART2, uartNotUsed, baudRate4800, IOPins, None, None)
#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    armPot,         sensorPotentiometer)
#pragma config(Sensor, in2,    goalerPot,      sensorPotentiometer)
#pragma config(Sensor, dgtl3,  heightEncoder,  sensorQuadEncoder)
#pragma config(Sensor, I2C_1,  rightEncoder,   sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  leftEncoder,    sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           goalerMotor,   tmotorVex393_HBridge, openLoop, reversed)
#pragma config(Motor,  port2,           rightFront,    tmotorVex393HighSpeed_MC29, openLoop, reversed, encoderPort, I2C_1)
#pragma config(Motor,  port3,           leftFront,     tmotorVex393HighSpeed_MC29, openLoop, encoderPort, I2C_2)
#pragma config(Motor,  port4,           heightRight,   tmotorVex393TurboSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           armRight,      tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           rightRear,     tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           leftRear,      tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port8,           armLeft,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           heightLeft,    tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port10,          clawMotor,     tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX2) // This code is for the VEX cortex platform
#pragma competitionControl(Competition) // Select Download method as "competition"
#include "Vex_Competition_Includes.c" //Main competition background code...do not modify!
#pragma systemFile

//============= Competition template for VEX EDR =============
// Pre-Autonomous Functions  All activities that occur before the competition starts ie clearing encoders, setting servo positions, ..
void pre_auton()
{
	bStopTasksBetweenModes = true;
	bDisplayCompetitionStatusOnLcd = false;
	slaveMotor(armRight,armLeft);
	slaveMotor(heightRight,heightLeft);
}//end pre_run
/*  when loading cone on Mobile Goal (MG) the claw can open wide than arm and get wreak havoc (bust chain, jam)
this version tries to stop the arm at coneZone - well before reaching armPot(max)
1 - slowly lift arm (in arm task)
2 - pause a moment to makesure claw is clear (arm & claw task)
3 - slowly open claw - (claw task)
4 - once clear - resume normal control
** TO DO soft limie limit how far the arm can go over goaler. Try for horizontal (drop cone OK & keeps claws constrained by brackets)
*/

//IT IS IMPERITIVE CO CONFIRM THE VARIABLES vs SENSOR VALUES frequently!!!
int armMax = 4000;	//armPot's value at max angle
int coneZone = armMax; //'sweet-spot' armPot reading where claw is intent on dropping cone. threshold where claw in danger
int greyZone = 800; //+- range grey-area where arm's between arm being forward & backward
int armLift = -50;	//direction / power applied to arm to slowly
int clawOpen = -40; //claw open direction / power
int pause1 = 30;	//first delay (in milli sec) before claw opens
int pause2 = 400;	//first delay (in milli sec) before claw opens


// global varaibles
int deadband = 20;
int MAX_POWER = 100;
int leftPower = 0;
int rightPower = 0;
int armAngle = 0;
int goalerAngle = 0;

task autonomous()
{
	/*PLACE CONE ON MOBILE GOAL AND TRY FOR 20 point CORNER
	CODE IS SET-UP FOR MB ON LEFT
	** IF PARTNER DOES MB ON LEFT cHANGING VARIABLE mobilGoalOnLeft TO -1 REVERSES DIRECTION
	* mobilGoalOnLeft USED *ONLY* WHEN TURNING
	*/
	int mobilGoalOnLeft = 1; //change which direction 'bot turns 1 = on left, -1 = right

	//ZERO ENCODERS
	SensorValue(armPot)=0;	//zero quatrature encoders (QE)
	SensorValue(heightEncoder)=0;
	resetMotorEncoder(rightFront);		//sero Integrated Motor Controllers (IME )
	resetMotorEncoder(leftFront);
	//pickup claw & hold
	motor[clawMotor]=MAX_POWER;
	wait1Msec(500);
	motor[clawMotor]=15; //hold claw shut
	
	//ready goaLer
	while(SensorValue(goalerPot)>1000){
		motor[goalerMotor] = -60;
	}
	motor[goalerMotor] = 0;
	//drive to mobile goal
	while(abs(getMotorEncoder(rightFront)) < 2000)  {
		motor[rightRear] = motor[rightFront]=-50;
		motor[leftRear] = motor[leftFront]=-50;
	}
	motor[rightRear] = motor[rightFront]=0;
	motor[leftRear] = motor[leftFront]=0;

	//lift MB
	while(SensorValue(goalerPot)<4050){
		motor[goalerMotor] = 120;
	}
	motor[goalerMotor] = 0;

	//lift cone onto MB
	while(SensorValue(armPot)<armMax-500){
		motor[armLeft]=70;
	}
	motor[clawMotor]=-20;
	motor[armLeft]=0;
	wait1Msec(200);
	//motor[clawMotor]=-50;
	wait1Msec(100);
	motor[clawMotor]=0;
	motor[armLeft]=-70;
	wait1Msec(1500);
	motor[armLeft]=0;
	motor[clawMotor]=0;

	//**** SET-UP FOR LEFT MOBILE GOAL - SET  mobilGoalOnLeft = -1 FOR RIGHT
	//turn around 180 degrees
	resetMotorEncoder(rightFront);		//sero Integrated Motor Controllers (IME )
	resetMotorEncoder(leftFront);
	while(abs(getMotorEncoder(rightFront)) < 700)  { //150 = 45, 300 = 90, 600 = 180 : negative value = direction of turn
		motor[rightRear] = motor[rightFront]=-60 * mobilGoalOnLeft;
		motor[leftRear] = motor[leftFront]=60 * mobilGoalOnLeft;
	}
	motor[rightRear] = motor[rightFront]=0;
	motor[leftRear] = motor[leftFront]=0;

	//drive toward 20pt
	resetMotorEncoder(rightFront);		//zero Integrated Motor Controllers (IME )
	resetMotorEncoder(leftFront);
	while(abs(getMotorEncoder(rightFront)) < 1500)  {
		motor[rightRear] = motor[rightFront]=-50;
		motor[leftRear] = motor[leftFront]=-50;
	}
	//stop -
	motor[rightRear] = motor[rightFront]=0;
	motor[leftRear] = motor[leftFront]=0;

	//turn 45deg toward center 
	resetMotorEncoder(rightFront);	
	resetMotorEncoder(leftFront);
	while(abs(getMotorEncoder(rightFront)) <100)  { //150 = 45, 300 = 90, 600 = 180 : negative value = direction of turn
		motor[rightRear] = motor[rightFront]=60 * mobilGoalOnLeft;
		motor[leftRear] = motor[leftFront]=-60 * mobilGoalOnLeft;
	}
	motor[rightRear] = motor[rightFront]=0;
	motor[leftRear] = motor[leftFront]=0;
	//put a goaler drop here to allow for a 7 point autonomous

	//drive toward starting bar center 
	resetMotorEncoder(rightFront);		//zero Integrated Motor Controllers (IME )
	resetMotorEncoder(leftFront);
	while(abs(getMotorEncoder(rightFront)) <300)  { //150 = 45, 300 = 90, 600 = 180 : negative value = direction of turn
		motor[rightRear] = motor[rightFront]=-60 ;
		motor[leftRear] = motor[leftFront]=-60 ;
	}
	motor[rightRear] = motor[rightFront]=0;
	motor[leftRear] = motor[leftFront]=0;

	//turn toward 20pt corner - - OK to here
	resetMotorEncoder(rightFront);		//sero Integrated Motor Controllers (IME )
	resetMotorEncoder(leftFront);
	while(abs(getMotorEncoder(rightFront)) < 450)  { //150 = 45, 300 = 90, 600 = 180 : negative value = direction of turn
		motor[rightRear] = motor[rightFront]=-50 * mobilGoalOnLeft;
		motor[leftRear] = motor[leftFront]=50 * mobilGoalOnLeft;
	}
	motor[rightRear] = motor[rightFront]=0;
	motor[leftRear] = motor[leftFront]=0;

	//drive into corner
	motor[leftRear] = motor[leftFront]= motor[rightRear] = motor[rightFront]=-80;
	wait1Msec(100);
	motor[leftRear] = motor[leftFront]= motor[rightRear] = motor[rightFront]=0;
	
	//resetMotorEncoder(rightFront);		//sero Integrated Motor Controllers (IME )
	//resetMotorEncoder(leftFront);
	//while(abs(getMotorEncoder(rightFront)) < 600)  { //150 = 45, 300 = 90, 600 = 180 : negative value = direction of turn
	//	motor[rightRear] = motor[rightFront]=-80;
	//	motor[leftRear] = motor[leftFront]=-80;
	//}
	
	//lower goaler
	while(SensorValue(goalerPot)>1000){
		motor[goalerMotor] = -80;
	}
	motor[goalerMotor] = 0;
	//backup
	motor[leftRear] = motor[leftFront]= motor[rightRear] = motor[rightFront]=80;
	while(SensorValue(goalerPot)< 4000){
		motor[goalerMotor] = 80;
	}
	motor[goalerMotor] = 0;
	wait1Msec(500);
	motor[leftRear] = motor[leftFront]= motor[rightRear] = motor[rightFront]=0;
	//drop MB
	
	//end of testing comments
	/*
	//drive away - maybe toward parking
	resetMotorEncoder(rightFront);		//sero Integrated Motor Controllers (IME )
	resetMotorEncoder(leftFront);
	while(abs(getMotorEncoder(rightFront)) < 300)  { //150 = 45, 300 = 90, 600 = 180 : negative value = direction of turn
	motor[rightRear] = motor[rightFront]=60;
	motor[leftRear] = motor[leftFront]=60;
	}*/
}	//end autonomous

task claw(){	while(true){
		if(vexRT[Btn5DXmtr2] == 1 || vexRT[Btn5UXmtr2] == 1)       	//CLOSE CLAW
		{
			motor[clawMotor]=MAX_POWER;
			wait1Msec(500);
			motor[clawMotor]=20; //hold claw shut
		}
		if(vexRT[Btn6DXmtr2] == 1 || vexRT[Btn6UXmtr2] == 1)  	//OPEN CLAW
		{
			if(SensorValue(armPot) <coneZone)
			{ //fully open claw
				motor[clawMotor]=MAX_POWER * -1 ;
				wait1Msec(500);
				motor[clawMotor]=0;
			}
			else if(SensorValue(armPot) >coneZone-greyZone) //claw opens slowly - param from auto say 30 for 300ms
			{ //arm past verticle, partial open claw
				motor[clawMotor]=clawOpen;
			}
		}
		else
		{
			motor[clawMotor]=0;      	//...stop the motor[.
		}
	}//end while
}//end claw

task arm(){		// ARM CONTROL
	while(true){
		if((vexRT[Ch2Xmtr2]) > deadband)	{ //move arm until coming close to cone zone
			if(SensorValue(armPot)< coneZone){
				motor[armLeft]=vexRT[Ch2Xmtr2]*0.8;
			}
			else if(SensorValue(armPot)> armMax-greyZone){
				motor[armLeft]=vexRT[Ch2Xmtr2]*0.3;
			}
		}
		else if(vexRT[Ch2Xmtr2] < deadband * -1)	{ //move arm toward front
			motor[armLeft]=vexRT[Ch2Xmtr2]*0.4;
		}
		else { //no movement - try to "soft lock" motors
			if(SensorValue(armPot) >700 && SensorValue(armPot) <coneZone - greyZone){ //arm is high enough to need soft lock but not past verticle
				motor[armLeft]=15;
			}
			else if(SensorValue(armPot) >coneZone){
				motor[armLeft]=-20;
			}
			else{
				motor[armLeft]=0;
			}
		}
	}
}//end arm

task drive(){		//DRIVE CONTROL
	while(true){
		// calculate arcade drive motor[ power
		if(abs((vexRT[Ch2] + vexRT[Ch1]))>deadband){
			leftPower =(vexRT[Ch2] + vexRT[Ch1]);
			rightPower =(vexRT[Ch2] - vexRT[Ch1]);
		}
		else {
			leftPower = 0;
			rightPower = 0;
		}
		// check against maximum
		if( abs(rightPower) > MAX_POWER)
			rightPower = sgn(rightPower) * MAX_POWER;
		if( abs(leftPower) > MAX_POWER )
			leftPower = sgn(leftPower) * MAX_POWER;
		motor[leftRear]= motor[leftFront]=leftPower;
		motor[rightRear]= motor[rightFront]=rightPower;
	}//end while
}//end drive

task usercontrol()
{
	//start control tasks
	startTask(drive);
	startTask(claw);
	startTask(arm);
	//zero encoders
	SensorValue(heightEncoder)=0;
	resetMotorEncoder(rightFront);
	resetMotorEncoder(leftFront);

	while(true){
		armAngle = SensorValue(armPot);
		goalerAngle = SensorValue(goalerPot);

		// GOALER
		if(abs(vexRT[Ch3]) > deadband)       	//If button 7L is pressed...
		{
			motor[goalerMotor]=vexRT[Ch3];    	//...raise the goalerSetMotor.
		}
		else                      		//Else (neither button is pressed)...
		{
			motor[goalerMotor]=0;      	//...stop the goalerSetMotor.
		}
		if(vexRT[Btn7D]==1){
			while(SensorValue(goalerPot)>1000){
				motor[goalerMotor] = -60;
			}
		}

		//HEIGHT
		if(abs(vexRT[Ch3Xmtr2])> deadband)
		{
			motor[heightLeft]=vexRT[Ch3Xmtr2];
		}
		else
		{
			motor[heightLeft]=0;
		}
	}//end while
}//end userControl
