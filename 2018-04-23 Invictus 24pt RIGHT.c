#pragma config(UART_Usage, UART2, uartNotUsed, baudRate4800, IOPins, None, None)
#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    armPot,         sensorPotentiometer)
#pragma config(Sensor, in2,    goalerPot,      sensorPotentiometer)
#pragma config(Sensor, dgtl3,  heightEncoder,  sensorQuadEncoder)
#pragma config(Sensor, I2C_1,  rightEncoder,   sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  leftEncoder,    sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           goalerMotor,   tmotorVex393_HBridge, openLoop, reversed)
#pragma config(Motor,  port2,           rightFront,    tmotorVex393TurboSpeed_MC29, openLoop, reversed, encoderPort, I2C_1)
#pragma config(Motor,  port3,           leftFront,     tmotorVex393TurboSpeed_MC29, openLoop, encoderPort, I2C_2)
#pragma config(Motor,  port4,           heightRight,   tmotorVex393TurboSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           armRight,      tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           rightRear,     tmotorVex393TurboSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           leftRear,      tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port8,           armLeft,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           heightLeft,    tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port10,          clawMotor,     tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX2) // This code is for the VEX cortex platform
#pragma competitionControl(Competition) // Select Download method as "competition"
#include "Vex_Competition_Includes.c" //Main competition background code...do not modify!
#pragma systemFile

//						INVICTUS WORLD PROGRAMMING
//							AUTONOMOUS = MOBILE GOAL ON RIGHT
//
//		IMPORTANT
//					BATTERY MUST BE FRESH & > 7.3v
//					remote's right joystick only puts-out +- 67 - need to multiply in arm()
//											CAUTION IF REPLACING PARTNER REMOTE


//============= Competition template for VEX EDR =============
// Pre-Autonomous Functions  All activities that occur before the competition starts ie clearing encoders, setting servo positions, ..
void pre_auton()
{
	bStopTasksBetweenModes = true;
	bDisplayCompetitionStatusOnLcd = false;
	slaveMotor(armRight,armLeft);
	slaveMotor(heightRight,heightLeft);
}//end pre_run


// variables
int armMax = 4000;	//armPot's value at max angle
int coneZone = armMax; //'sweet-spot' armPot reading where claw is intent on dropping cone. threshold where claw in danger
int greyZone = 800; //+- range grey-area where arm's between arm being forward & backward
int clawOpen = -40; //claw open direction / power - used in clawOnGoal()
int pause1 = 300;	//first delay
int iBrake = 50;	//e-braking delay
int clawPower = 0;
int deadband = 15;
int MAX_POWER = 100;
int leftPower = 0;
int rightPower = 0;
int armAngle = 0;
int goalerAngle = 0;


//functions
//	drive to distance using encoder ticks
void eDrive(int l, int r, int e){
	resetMotorEncoder(rightFront);
	resetMotorEncoder(leftFront);
	wait1Msec(pause1);
	while(abs(getMotorEncoder(rightFront)) < e)  {
		motor[rightRear] = motor[rightFront]=r;
		motor[leftRear] = motor[leftFront]=l;}
	wait1Msec(iBrake);
	motor[rightRear] = motor[rightFront]=0;
	motor[leftRear] = motor[leftFront]=0;
	wait1Msec(iBrake);
	motor[rightRear] = motor[rightFront]=r *-.5;
	motor[leftRear] = motor[leftFront]=l * -.5;
	wait1Msec(iBrake);
	motor[rightRear] = motor[rightFront]=0;
	motor[leftRear] = motor[leftFront]=0;
}//end eDrive

//timed drive
void tDrive(int l, int r, int t){
	wait1Msec(pause1);
	motor[rightRear] = motor[rightFront]=r;
	motor[leftRear] = motor[leftFront]=l;
	wait1Msec(t);
	motor[rightRear] = motor[rightFront]=0;
	motor[leftRear] = motor[leftFront]=0;
	wait1Msec(iBrake);
	motor[rightRear] = motor[rightFront]=r *-.5;
	motor[leftRear] = motor[leftFront]=l * -.5;
	wait1Msec(iBrake);
	motor[rightRear] = motor[rightFront]=0;
	motor[leftRear] = motor[leftFront]=0;
}//end tDrive

//put cone on mobile goal
void coneOnGoal(void){
	while(SensorValue(armPot)<3500){
		motor[armLeft]=MAX_POWER;	}
	motor[clawMotor]=-20;
	motor[armLeft]=0;
	wait1Msec(200);
	motor[clawMotor]=0;
	motor[armLeft]=MAX_POWER * -1;
	wait1Msec(1500);
	motor[armLeft]=0;
	motor[clawMotor]=clawOpen;
	wait1Msec(250);
	motor[clawMotor]=0;
	clawPower=0;
}

//	tasks
task autonomous()  //BATTERY AT 7.3 volts
{
	//grap claw
	motor[clawMotor]=MAX_POWER;
	wait1Msec(500);
	motor[clawMotor]=15;

	//position goaLer
	while(SensorValue(goalerPot)>1250){
		motor[goalerMotor] = -60;
	}
	motor[goalerMotor] = 5;

	//drive to mobile goal (MB)
	eDrive(-75, -80, 850);  //

	//lift MB
	while(SensorValue(goalerPot)<4050){
		motor[goalerMotor] = 120;
	}
	motor[goalerMotor] = 0;

	//lift cone onto MB - copy of coneOverGoal()
	coneOnGoal();

	//drive back toward corner
	eDrive(75, 80, 750);

	//turn 45deg toward center
	tDrive(-70, 70, 850);

	//drive toward starting bar center
	eDrive(-80, -80, 250);

	//turn toward 20pt corner
	tDrive(-70, 70, 750);

	//CHARRRRRRRRRRRRGEEEEEEEEE into corner
	motor[leftRear] = motor[leftFront]= motor[rightRear] = motor[rightFront]=-110;
	wait1Msec(400);  //tweak both timers for 20pt zone
	motor[goalerMotor] = -60;
	wait1Msec(1000);
	motor[goalerMotor] = 0;
	motor[leftRear] = motor[leftFront]= motor[rightRear] = motor[rightFront]=0;

	//backup
	tDrive(100,100,700);

	//turn toward parking / mobile goal
	tDrive(-70,70,375);

	//drive toward parking
	tDrive(90,90,1300);

	/**/
}	//end autonomous

//claw control
task claw(){	while(true){
		if(vexRT[Btn5DXmtr2] == 1 || vexRT[Btn5UXmtr2] == 1)       	//CLOSE CLAW
		{
			motor[clawMotor]=MAX_POWER;
			wait1Msec(500);
			clawPower=15; //hold claw shut
		}
		if(vexRT[Btn6DXmtr2] == 1 || vexRT[Btn6UXmtr2] == 1)  	//OPEN CLAW
		{
			clawPower = 0;
			if(SensorValue(armPot) <coneZone)
			{ //fully open claw
				motor[clawMotor]=MAX_POWER * -1 ;
				wait1Msec(500);
				motor[clawMotor]=clawPower;

			}
			else if(SensorValue(armPot) >coneZone-greyZone)  //arm past verticle, partial open claw
			{
				motor[clawMotor]=clawOpen;
				wait1Msec(200);
				motor[clawMotor]=clawPower;
			}
		}
		else
		{
			motor[clawMotor]=clawPower;
		}
	}//end while
}//end claw

//arm control
task arm(){
	while(true){
		if((vexRT[Ch2Xmtr2]) > deadband)	{ 			//move arm until coming close to cone zone
			if(SensorValue(armPot)< coneZone){
				motor[armLeft]=vexRT[Ch2Xmtr2]*1.5;	//***!!!!  the remote control only put out 65, had to increase
			}
			else if(SensorValue(armPot)> armMax-greyZone){
				motor[armLeft]=vexRT[Ch2Xmtr2] *0.8;
			}
		}
		else if(vexRT[Ch2Xmtr2] < deadband * -1)	{ //move arm toward front
			motor[armLeft]=vexRT[Ch2Xmtr2]*0.8;
		}
		else { //no movement - try to "soft lock" motors
			if(SensorValue(armPot) >700 && SensorValue(armPot) <coneZone - greyZone){ //arm is high enough to need soft lock but not past verticle
				motor[armLeft]=15;
			}
			else if(SensorValue(armPot) >coneZone){
				motor[armLeft]=-20;
			}
			else{
				motor[armLeft]=0;
			}
		}
	}
}//end arm

//drive control  	*?	should we use 'steps' instead of variable ???
task drive(){
	while(true){
		if(abs((vexRT[Ch2] + vexRT[Ch1]))>deadband){	// calculate arcade drive motor[ power
			leftPower =(vexRT[Ch2] + vexRT[Ch1])* 0.8;	//coefficient = decrease joystick sensitivity
			rightPower =(vexRT[Ch2] - vexRT[Ch1]) * 0.8;
		}
		else {
			leftPower = 0;
			rightPower = 0;
		}
		// check against maximum
		if( abs(rightPower) > MAX_POWER)
			rightPower = sgn(rightPower) * MAX_POWER;
		if( abs(leftPower) > MAX_POWER )
			leftPower = sgn(leftPower) * MAX_POWER;
		motor[leftRear]= motor[leftFront]=leftPower;
		motor[rightRear]= motor[rightFront]=rightPower;
	}//end while
}//end drive


void clawOverGoal(void) { //claw/arm routing from autonomous
	stopTask(arm); //stop tasks to give control to coneOnGoal
	stopTask(claw);
	coneOnGoal();
	startTask(arm);
	startTask(claw);
}

task goaler(){
	while(true){
		if(abs(vexRT[Ch3]) > deadband)       	//If button 7L is pressed...
		{
			motor[goalerMotor]=vexRT[Ch3];    	//...raise the goalerSetMotor.
		}
		else                      		//Else (neither button is pressed)...
		{
			motor[goalerMotor]=0;      	//...stop the goalerSetMotor.
		}
		if(vexRT[Btn7D]==1){
			while(SensorValue(goalerPot)>1000){
				motor[goalerMotor] = -60;
			}
		}
	}
}//end goaler()

task usercontrol()
{
	//start control tasks
	startTask(drive);
	startTask(claw);
	startTask(arm);
	startTask(goaler);

	while(true){
		armAngle = SensorValue(armPot);
		goalerAngle = SensorValue(goalerPot);

		//automatically dump cone on goaler
		if(vexRT[Btn8DXmtr2]==1){
			clawOverGoal();
			}

		//HEIGHT
		if(abs(vexRT[Ch3Xmtr2])> deadband)
		{
			motor[heightLeft]=vexRT[Ch3Xmtr2];
		}
		else
		{
			motor[heightLeft]=0;
		}
	}//end while
}//end userControl
